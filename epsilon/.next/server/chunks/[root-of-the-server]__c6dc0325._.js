module.exports = {

"[project]/.next-internal/server/app/api/network/[id]/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}}),
"[project]/src/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST,
    "auth": ()=>auth,
    "signIn": ()=>signIn,
    "signOut": ()=>signOut
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/credentials.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/core/providers/credentials.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/api.ts [app-route] (ecmascript)");
;
;
;
const mockLoginEnabled = process.env.NEXT_PUBLIC_ENABLE_MOCK_LOGIN === 'true' || process.env.ENABLE_MOCK_LOGIN === 'true' || ("TURBOPACK compile-time value", "development") !== 'production';
const mockPersonas = [
    {
        username: 'mock-operator',
        password: process.env.MOCK_OPERATOR_PASSWORD ?? 'mock-operator',
        profile: {
            id: 'mock-operator',
            handle: 'Dev Operator',
            faction: 'epsilon',
            factionRankActual: 'systems',
            factionRankPublic: 'operator',
            apiToken: 'mock-operator-token'
        }
    },
    {
        username: 'mock-police',
        password: process.env.MOCK_POLICE_PASSWORD ?? 'mock-police',
        profile: {
            id: 'mock-police',
            handle: 'OMG Liaison',
            faction: 'o_m_g',
            factionRankActual: 'investigator',
            factionRankPublic: 'officer',
            apiToken: 'mock-police-token'
        }
    }
];
const providers = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
        id: 'credentials',
        name: 'Credentials',
        credentials: {
            username: {
                label: 'Username',
                type: 'text'
            },
            password: {
                label: 'Password',
                type: 'password'
            }
        },
        async authorize (credentials) {
            const username = credentials?.username?.trim();
            const password = credentials?.password;
            if (!username || !password) {
                throw new Error('Missing username or password');
            }
            try {
                const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loginWithCredentials"])(username, password);
                if (response && response.status === 'ok') {
                    // Return exactly what you want to copy into the JWT on first sign-in
                    const u = response.user;
                    return {
                        id: u.id,
                        handle: u.handle ?? null,
                        faction: u.faction ?? null,
                        factionRankActual: u.factionRankActual ?? null,
                        factionRankPublic: u.factionRankPublic ?? null,
                        apiToken: response.token
                    };
                }
                // Upstream error:
                const msg = response?.message || 'Invalid credentials';
                throw new Error(msg);
            } catch (e) {
                throw new Error(e instanceof Error ? e.message : String(e));
            }
        }
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
        id: 'police',
        name: 'Police',
        credentials: {
            username: {
                label: 'Username',
                type: 'text'
            },
            password: {
                label: 'Password',
                type: 'password'
            }
        },
        async authorize (credentials) {
            const username = credentials?.username?.trim();
            const password = credentials?.password;
            if (!username || !password) {
                throw new Error('Missing username or password');
            }
            try {
                const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loginWithCredentials"])(username, password);
                if (response && response.status === 'ok') {
                    const u = response.user;
                    if (u.faction !== 'o_m_g') throw new Error('You don have access to this database');
                    return {
                        id: u.id,
                        handle: u.handle ?? null,
                        faction: u.faction ?? null,
                        factionRankActual: u.factionRankActual ?? null,
                        factionRankPublic: u.factionRankPublic ?? null,
                        apiToken: response.token
                    };
                }
                // Upstream error:
                const msg = response?.message || 'Invalid credentials';
                throw new Error(msg);
            } catch (e) {
                throw new Error(e instanceof Error ? e.message : String(e));
            }
        }
    })
];
if ("TURBOPACK compile-time truthy", 1) {
    providers.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$credentials$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
        id: 'mock',
        name: 'Mock Access',
        credentials: {
            username: {
                label: 'Persona',
                type: 'text'
            },
            password: {
                label: 'Passphrase',
                type: 'password'
            }
        },
        async authorize (credentials) {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            const username = credentials?.username?.trim();
            const password = credentials?.password;
            if (!username || !password) {
                throw new Error('Missing persona or passphrase');
            }
            const persona = mockPersonas.find((entry)=>entry.username === username && entry.password === password);
            if (!persona) {
                throw new Error('Mock credentials invalid');
            }
            return {
                id: persona.profile.id,
                handle: persona.profile.handle,
                faction: persona.profile.faction,
                factionRankActual: persona.profile.factionRankActual,
                factionRankPublic: persona.profile.factionRankPublic,
                apiToken: persona.profile.apiToken
            };
        }
    }));
}
const { auth, signIn, signOut, handlers: { GET, POST } } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])({
    pages: {
        signIn: '/login'
    },
    session: {
        strategy: 'jwt'
    },
    providers,
    callbacks: {
        async jwt ({ token, user, trigger, session }) {
            // First sign-in: copy fields from user → token
            if (user) {
                token.id = user.id;
                token.handle = user.handle ?? null;
                token.faction = user.faction ?? null;
                token.factionRankActual = user.factionRankActual ?? null;
                token.factionRankPublic = user.factionRankPublic ?? null;
                // Keep apiToken on the token (server-side). Only expose to client if you truly need it.
                token.apiToken = user.apiToken;
            }
            // Optional: allow client-driven session update to tweak selected fields
            if (trigger === 'update' && session?.user) {
                const su = session.user;
                if (su.handle !== undefined) token.handle = su.handle;
                if (su.faction !== undefined) token.faction = su.faction;
                if (su.factionRankActual !== undefined) token.factionRankActual = su.factionRankActual;
                if (su.factionRankPublic !== undefined) token.factionRankPublic = su.factionRankPublic;
            }
            return token;
        },
        async session ({ session, token }) {
            // ⚠️ Only expose non-sensitive data to the browser
            session.user = {
                ...session.user,
                id: token.userId,
                handle: token.handle ?? null,
                faction: token.faction ?? null,
                factionRankActual: token.factionRankActual ?? null,
                factionRankPublic: token.factionRankPublic ?? null
            };
            // If you truly need the apiToken client-side, expose it (not generally recommended)
            if (token.apiToken) {
                session.apiToken = token.apiToken;
            }
            return session;
        }
    }
});
}),
"[project]/src/services/api.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__,
    "del": ()=>del,
    "get": ()=>get,
    "loginWithCredentials": ()=>loginWithCredentials,
    "patch": ()=>patch,
    "post": ()=>post,
    "put": ()=>put,
    "setAuthToken": ()=>setAuthToken
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
;
;
;
/**
 * Shared Axios instance for server/client requests.
 * - Uses NEXT_PUBLIC_API_BASE_URL in the browser and API_BASE_URL on the server.
 * - Exposes a helper to set/clear the AuthToken header.
 */ const baseURL = ("TURBOPACK compile-time truthy", 1) ? process.env.API_BASE_URL : "TURBOPACK unreachable";
if (!baseURL) {
    // Fail fast so misconfiguration is obvious during development
    // (in production you might want to log instead).
    console.warn('[api] baseURL is not defined. Did you set API_BASE_URL / NEXT_PUBLIC_API_BASE_URL?');
}
const api = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
    baseURL: baseURL,
    timeout: 10000
});
function setAuthToken(token) {
    if (token) {
        api.defaults.headers.common.AuthToken = token;
    } else {
        delete api.defaults.headers.common.AuthToken;
    }
}
async function loginWithCredentials(username, password) {
    try {
        const { data } = await api.get('/Login/giger', {
            params: {
                username,
                password
            }
        });
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        const profileResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${baseURL}/User/private/byUsername`, {
            params: {
                userName: username
            },
            headers: {
                AuthToken: data
            }
        });
        return {
            status: 'ok',
            user: profileResponse.data,
            token: data
        };
    } catch (e) {
        return {
            status: 'error',
            message: e
        };
    }
}
const __TURBOPACK__default__export__ = api;
async function get(url) {
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const token = session.apiToken;
    if (!token) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Missing API token'
        }, {
            status: 401
        });
    }
    const upstreamUrl = `${process.env.API_BASE_URL}/${url}`;
    const upstream = await fetch(upstreamUrl, {
        method: "GET",
        headers: {
            AuthToken: token
        },
        cache: "no-store"
    });
    const rawData = await upstream.json().catch(()=>null);
    if (!rawData) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Invalid JSON from upstream'
        }, {
            status: 502
        });
    }
    return rawData;
}
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || process.env.API_BASE_URL || '';
const buildUrl = (path)=>path.startsWith('http') ? path : `${API_BASE}${path.startsWith('/') ? '' : '/'}${path}`;
async function handleResponse(res) {
    if (!res.ok) {
        // Try to extract a useful error message from JSON, otherwise use status text
        let message = `Request failed (${res.status})`;
        try {
            const data = await res.json();
            message = data?.error || data?.message || message;
        } catch  {
        // ignore JSON parse errors
        }
        throw new Error(message);
    }
    // 204 No Content or empty body
    if (res.status === 204) return null;
    const ct = res.headers.get('content-type') || '';
    return ct.includes('application/json') ? res.json() : res.text();
}
async function del(path, options = {}) {
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const token = session.apiToken;
    const url = buildUrl(path);
    const res = await fetch(url, {
        method: 'DELETE',
        // keep headers unobtrusive; only set JSON header if caller provides a body
        headers: {
            AuthToken: token
        }
    });
    return handleResponse(res);
}
async function post(url, payload) {
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const token = session.apiToken;
    if (!token) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Missing API token'
        }, {
            status: 401
        });
    }
    const base = process.env.API_BASE_URL || '';
    const upstreamUrl = `${base}${url.startsWith('/') ? '' : '/'}${url}`;
    // If payload is FormData, let fetch set Content-Type; otherwise send JSON
    const isFormData = typeof FormData !== 'undefined' && payload instanceof FormData;
    const res = await fetch(upstreamUrl, {
        method: 'POST',
        headers: {
            AuthToken: token,
            ...isFormData ? {} : {
                'Content-Type': 'application/json'
            }
        },
        body: isFormData ? payload : payload ? JSON.stringify(payload) : undefined,
        cache: 'no-store'
    });
    // Keep behavior similar to your GET: try to parse JSON, else fail
    const rawData = await res.json().catch(()=>null);
    if (!rawData) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Invalid JSON from upstream'
        }, {
            status: 502
        });
    }
    return rawData;
}
async function patch(path, payload) {
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const token = session.apiToken;
    if (!token) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Missing API token'
        }, {
            status: 401
        });
    }
    const url = buildUrl(path);
    // If payload is FormData, let fetch set Content-Type; otherwise send JSON
    const isFormData = typeof FormData !== 'undefined' && payload instanceof FormData;
    const res = await fetch(url, {
        method: 'PATCH',
        headers: {
            AuthToken: token,
            ...isFormData ? {} : {
                'Content-Type': 'application/json'
            }
        },
        body: isFormData ? payload : payload ? JSON.stringify(payload) : undefined,
        cache: 'no-store'
    });
    return handleResponse(res);
}
async function put(path, payload) {
    const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
    if (!session) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unauthorized'
        }, {
            status: 401
        });
    }
    const token = session.apiToken;
    if (!token) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Missing API token'
        }, {
            status: 401
        });
    }
    const url = buildUrl(path);
    // If payload is FormData, let fetch set Content-Type; otherwise send JSON
    const isFormData = typeof FormData !== 'undefined' && payload instanceof FormData;
    const res = await fetch(url, {
        method: 'PUT',
        headers: {
            AuthToken: token,
            ...isFormData ? {} : {
                'Content-Type': 'application/json'
            }
        },
        body: isFormData ? payload : payload ? JSON.stringify(payload) : undefined,
        cache: 'no-store'
    });
    return handleResponse(res);
}
}),
"[project]/src/app/api/mappers/subnetwork.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>mapSubnetwork
});
function mapSubnetwork(data) {
    return {
        id: data.id,
        name: data.name,
        users: data.users,
        network: data.networkId,
        accessPoint: data.accessPoint,
        firewall: data.firewall
    };
}
}),
"[project]/src/app/api/mappers/network.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>mapNetwork
});
function mapNetwork(data, subnetworks) {
    return {
        id: data.id,
        name: data.name,
        subnetworks: subnetworks.filter((s)=>data.subnetworks.includes(s.id)),
        admin: data.adminId || ''
    };
}
}),
"[project]/src/app/api/network/[id]/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/api.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$mappers$2f$subnetwork$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/app/api/mappers/subnetwork.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$mappers$2f$network$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/app/api/mappers/network.ts [app-route] (ecmascript)");
;
;
;
;
async function GET(_request, { params }) {
    const [networkResponse, subnetworksResponse] = await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["get"])(`Networks/network?id=${params.id}`),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["get"])('Networks/subnetwork/all')
    ]);
    const subnetworks = subnetworksResponse.map(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$mappers$2f$subnetwork$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
    const network = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$app$2f$api$2f$mappers$2f$network$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(networkResponse, subnetworks);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        network
    }, {
        status: 200
    });
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__c6dc0325._.js.map